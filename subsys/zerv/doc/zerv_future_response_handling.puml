@startuml zerv_asynchronous_request_handling_with_futures
skinparam {
    sequenceArrowThickness 2
    roundcorner 12
    maxmessagesize 200
}

participant "**Client Thread**" as client

box "zerv framework implementation" #LightGray
    participant "**ZIT Client API**" as zerv_api
    queue "**Service Queue**" as zerv_queue
    database "**Service Heap**" as zerv_heap
    participant "**Service Thread**" as zerv_thread
    participant "**zerv_handle_request**" as zerv_req_handler
    participant "**req1_handler**" as req1_handler
end box

participant "**scheduler**" as sched

== Implemented Service Thread ==

    ' Initialisation
    activate zerv_thread
    zerv_thread -> zerv_queue ++: **zerv_get_cmd_input(...)**
    zerv_queue --> sched --++: **k_fifo_get(...)** (blocking service thread)
    deactivate zerv_thread

== Client thread ==

    sched -> client --++: schedule

    ' Client request call
    rnote over client: Client calls the request **req1** on service **service**
    client -> zerv_api ++: **ZERV_CMD_CALL(service, req1, params*, response*)** 
    zerv_api -> zerv_api: lock req1 mutex
    zerv_api -> zerv_heap ++: allocate params on the heap
    zerv_heap --> zerv_api: zerv_req_params*
    zerv_api ->o zerv_queue: **k_fifo_put(zerv_req_params*)** (Send the request to the service thread)
    zerv_api --> sched --++: **k_sem_take(response_sem)** (client thread blocked)
    deactivate client

== Implemented Service Thread ==

    ' zerv request handling
    sched -> zerv_queue --++: schedule
    activate zerv_thread
    zerv_queue --> zerv_thread --: zerv_req_params*
    zerv_thread -> zerv_req_handler ++: zerv_req_params*
    zerv_req_handler -> req1_handler --++: **zerv_handle_request(zerv_req_params*)**
    rnote over req1_handler: The handler cannot handle the request\nimmediately, so it returns **ZERV_RC_FUTURE**
    req1_handler --> zerv_req_handler --++: **ZERV_RC_FUTURE**
    zerv_req_handler -> zerv_req_handler: store zerv_req_params* in the req1 future storage
    zerv_req_handler --> sched --++: **k_sem_give(response_sem)** (blocking zit thread)
    deactivate zerv_thread

== Client thread ==

' Client response handling
    sched -> zerv_api --++: schedule
    activate client
    rnote over zerv_api: In contrast to the synchronous\nreq1 api mutex is still locked
    zerv_api --> client --: return code: **ZERV_RC_FUTURE**
    rnote over client: data in *resp is not ready

    note left: The client thread is now posed with a choice:\n1. Wait for the response to be ready\n2. Check later if the response is ready

    ' Client can now choose to wait or check later. We show the wait case here.
    client -> zerv_api ++: **zerv_get_future(...)**
    alt timeout == no_wait
        zerv_api --> zerv_api: **k_sem_take(req1_future->response_sem, no_wait)**
        rnote over zerv_api: The service has not yet\nresponded
        zerv_api --> client --: return code: **ZERV_RC_TIMEOUT** 
        rnote over client: data in *resp is not ready, client can check later
    else timeout == forever (or larger than no wait)
        client -> zerv_api ++: **zerv_get_future(*resp, timeout)**
        zerv_api --> sched--++: **k_sem_take(req1_future->response_sem, forever)** (blocking client thread)
        deactivate client
    end alt


== SYSTEM ==
    sched ->] --: Other stuff
    rnote over client, sched: System is doing other stuff
    sched <-] ++: Other stuff is waiting   

== Implemented Service Thread ==
    sched -> zerv_thread --++: schedule
    rnote over zerv_thread: Original request is now complete
    zerv_thread -> zerv_thread: set req1_future->resp 
    zerv_thread --> sched --++: **k_sem_give(req1_future->response_sem)** (blocking zit thread)

== Client thread ==
    sched -> zerv_api --++: schedule
    activate client
    zerv_api -> zerv_api: unlock req1 mutex
    zerv_api -> zerv_api: copy resp->future->resp to *resp
    zerv_api --> client --: return code from req1_future->response
    rnote over client: data in *resp is now ready
    
@enduml