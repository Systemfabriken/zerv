@startuml zit_serv_synchronous_request_handling
skinparam {
    sequenceArrowThickness 2
    roundcorner 12
    SequenceGroupBodyBackgroundColor 01FF0110
    maxmessagesize 200
}

participant client_thread as client


box "zit_serv framework implementation" #LightGray
    participant zit_serv_api as zit_api
    queue zit_serv_queue as zit_queue
    participant zit_serv_thread as zit_thread
    participant zit_serv_req_handler as zit_req_handler
    participant req1_handler
end box

participant scheduler as sched

== Zit thread ==

' Initialisation
activate zit_thread
zit_thread -> zit_queue ++: k_fifo_get
zit_queue --> sched --++: wait for zit_serv_req (blocking zit thread)
deactivate zit_thread

== Client thread ==

sched -> client --++: schedule

' Client request call
client -> zit_api ++: zit_serv.req1: param, *resp 
zit_api -> zit_api: lock req1 mutex
zit_api ->o zit_queue: k_fifo_put: zit_serv_req*
zit_api --> sched --++: k_sem_take: response_sem (client thread blocked)
deactivate client

== Zit thread ==

' zit_serv request handling
sched -> zit_queue --++: schedule
activate zit_thread
zit_queue --> zit_thread --: zit_serv_req*
zit_thread -> zit_req_handler ++: zit_serv_req*
zit_req_handler -> req1_handler --++: handle_request: param, *resp
rnote over req1_handler: do non-blocking work\nand update *resp
req1_handler --> zit_req_handler --++: return code
zit_req_handler --> sched --++: k_sem_give: response_sem (blocking zit thread)
deactivate zit_thread

== Client thread ==

' Client response handling
sched -> zit_api --++: schedule
activate client
zit_api -> zit_api: unlock req1 mutex
zit_api --> client --: return code
rnote over client: Data in *resp\nis now available

@enduml