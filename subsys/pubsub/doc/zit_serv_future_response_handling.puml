@startuml zit_serv_asynchronous_request_handling_with_futures
skinparam {
    sequenceArrowThickness 2
    roundcorner 12
    maxmessagesize 200
}

participant "**Client Thread**" as client

box "zit_serv framework implementation" #LightGray
    participant "**ZIT Client API**" as zit_api
    queue "**Service Queue**" as zit_queue
    database "**Service Heap**" as zit_heap
    participant "**Service Thread**" as zit_thread
    participant "**zit_serv_handle_request**" as zit_req_handler
    participant "**req1_handler**" as req1_handler
end box

participant "**scheduler**" as sched

== Implemented Service Thread ==

    ' Initialisation
    activate zit_thread
    zit_thread -> zit_queue ++: **zit_serv_get_req(...)**
    zit_queue --> sched --++: **k_fifo_get(...)** (blocking service thread)
    deactivate zit_thread

== Client thread ==

    sched -> client --++: schedule

    ' Client request call
    rnote over client: Client calls the request **req1** on service **service**
    client -> zit_api ++: **zit_client_call(service, req1, params*, response*)** 
    zit_api -> zit_api: lock req1 mutex
    zit_api -> zit_heap ++: allocate params on the heap
    zit_heap --> zit_api: zit_req_params*
    zit_api ->o zit_queue: **k_fifo_put(zit_req_params*)** (Send the request to the service thread)
    zit_api --> sched --++: **k_sem_take(response_sem)** (client thread blocked)
    deactivate client

== Implemented Service Thread ==

    ' zit_serv request handling
    sched -> zit_queue --++: schedule
    activate zit_thread
    zit_queue --> zit_thread --: zit_req_params*
    zit_thread -> zit_req_handler ++: zit_req_params*
    zit_req_handler -> req1_handler --++: **zit_serv_handle_request(zit_req_params*)**
    rnote over req1_handler: The handler cannot handle the request\nimmediately, so it returns **ZIT_RC_FUTURE**
    req1_handler --> zit_req_handler --++: **ZIT_RC_FUTURE**
    zit_req_handler -> zit_req_handler: store zit_req_params* in the req1 future storage
    zit_req_handler --> sched --++: **k_sem_give(response_sem)** (blocking zit thread)
    deactivate zit_thread

== Client thread ==

' Client response handling
    sched -> zit_api --++: schedule
    activate client
    rnote over zit_api: In contrast to the synchronous\nreq1 api mutex is still locked
    zit_api --> client --: return code: **ZIT_RC_FUTURE**
    rnote over client: data in *resp is not ready

    note left: The client thread is now posed with a choice:\n1. Wait for the response to be ready\n2. Check later if the response is ready

    ' Client can now choose to wait or check later. We show the wait case here.
    client -> zit_api ++: **zit_client_get_future(...)**
    alt timeout == no_wait
        zit_api --> zit_api: **k_sem_take(req1_future->response_sem, no_wait)**
        rnote over zit_api: The service has not yet\nresponded
        zit_api --> client --: return code: **ZIT_RC_TIMEOUT** 
        rnote over client: data in *resp is not ready, client can check later
    else timeout == forever (or larger than no wait)
        client -> zit_api ++: **zit_client_get_future(*resp, timeout)**
        zit_api --> sched--++: **k_sem_take(req1_future->response_sem, forever)** (blocking client thread)
        deactivate client
    end alt


== SYSTEM ==
    sched ->] --: Other stuff
    rnote over client, sched: System is doing other stuff
    sched <-] ++: Other stuff is waiting   

== Implemented Service Thread ==
    sched -> zit_thread --++: schedule
    rnote over zit_thread: Original request is now complete
    zit_thread -> zit_thread: set req1_future->resp 
    zit_thread --> sched --++: **k_sem_give(req1_future->response_sem)** (blocking zit thread)

== Client thread ==
    sched -> zit_api --++: schedule
    activate client
    zit_api -> zit_api: unlock req1 mutex
    zit_api -> zit_api: copy resp->future->resp to *resp
    zit_api --> client --: return code from req1_future->response
    rnote over client: data in *resp is now ready
    
@enduml